name: Nuke Actions (runs, artifacts, releases, tags) [autosleep + initial wait]

on:
  workflow_dispatch:
    inputs:
      branch:
        description: Branch a limpar
        default: main
        required: true
      tagPrefix:
        description: Prefixo de tags a remover (refs/tags/<prefix>*)
        default: release-
        required: true
      nearLimitThreshold:
        description: Faz sleep quando faltarem <= este n¬∫ de requests
        default: "50"
        required: true

permissions:
  actions: write     # apagar runs + artifacts
  contents: write    # apagar releases + tags

jobs:
  nuke:
    runs-on: ubuntu-latest
    timeout-minutes: 420

    steps:
      # Espera 1 hora logo no arranque
      - name: ‚è≥ Cooldown inicial (aguardar 1h)
        run: |
          echo "Starting with a hard 1-hour cooldown to clear rate limits‚Ä¶"
          sleep 3660

      # (opcional) se ainda estiver perto do limite, espera at√© ao reset real
      - name: ‚è≥ Verificar rate limit e aguardar at√© reset se necess√°rio
        uses: actions/github-script@v7
        with:
          script: |
            const sleep = (ms) => new Promise(r => setTimeout(r, ms));
            const r = await github.request('GET /rate_limit');
            const core = r.data.resources.core;
            const now = Math.floor(Date.now()/1000);
            const wait = Math.max(0, core.reset - now) + 5;
            console.log(`Remaining=${core.remaining}/${core.limit} ‚Äî reset=${new Date(core.reset*1000).toISOString()}`);
            if (wait > 5) {
              console.log(`Waiting ${wait}s until real reset‚Ä¶`);
              await sleep(wait * 1000);
            } else {
              console.log('No extra wait needed.');
            }

      - name: üßπ Nuke repo (artifacts/runs/releases/tags) com auto-wait
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const branch = core.getInput('branch') || 'main';
            const tagPrefix = core.getInput('tagPrefix') || 'release-';
            const NEAR_LIMIT = parseInt(core.getInput('nearLimitThreshold') || '50', 10);
            const snooze = (ms) => new Promise(r => setTimeout(r, ms));

            async function getRate() {
              const r = await github.request('GET /rate_limit');
              return r.data.resources.core; // {limit, remaining, reset}
            }
            async function waitForReset(resetEpochSec) {
              const now = Math.floor(Date.now()/1000);
              const waitSec = Math.max(0, resetEpochSec - now) + 5;
              core.info(`‚è≥ A aguardar ${waitSec}s at√© ao reset‚Ä¶`);
              await snooze(waitSec*1000);
            }
            async function ensureBudget() {
              const coreRate = await getRate();
              core.info(`üîã Budget: remaining=${coreRate.remaining}/${coreRate.limit} (reset @ ${new Date(coreRate.reset*1000).toISOString()})`);
              if (coreRate.remaining <= NEAR_LIMIT) {
                await waitForReset(coreRate.reset);
              }
            }
            async function safeCall(fn, label) {
              for (let attempt=1; attempt<=5; attempt++) {
                try {
                  await ensureBudget();
                  return await fn();
                } catch (e) {
                  const status = e.status || e?.response?.status;
                  const msg = e.message || (e?.response?.data?.message);
                  const reset = Number(e?.response?.headers?.['x-ratelimit-reset'] || 0);
                  core.warning(`${label} ‚Üí erro (attempt ${attempt}): ${status} ${msg || ''}`);
                  if (status === 403 && /rate limit/i.test(String(msg))) {
                    if (reset) { await waitForReset(reset); continue; }
                    await snooze(60_000); continue;
                  }
                  await snooze(attempt * 3000);
                }
              }
              throw new Error(`${label} falhou ap√≥s retries.`);
            }

            // ---------- 1) ARTIFACTS ----------
            let artifactsDeleted = 0, artifactsFailed = 0;
            core.startGroup('üßπ Apagar TODOS os artifacts (repo-wide)');
            for await (const page of github.paginate.iterator(
              github.rest.actions.listArtifactsForRepo,
              { owner, repo, per_page: 100 }
            )) {
              for (const art of page.data) {
                try {
                  await safeCall(
                    () => github.rest.actions.deleteArtifact({ owner, repo, artifact_id: art.id }),
                    `deleteArtifact id=${art.id} name=${art.name}`
                  );
                  artifactsDeleted++;
                } catch (e) {
                  artifactsFailed++;
                  core.warning(`Artifact ${art.id} (${art.name}) falhou: ${e.message}`);
                }
              }
            }
            core.endGroup();
            core.summary.addHeading('Artifacts')
              .addTable([['Deleted','Failed'],[String(artifactsDeleted), String(artifactsFailed)]]);

            // ---------- 2) RUNS ----------
            let runsTotal = 0, runsDeleted = 0, runsFailed = 0;
            core.startGroup(`üßπ Apagar TODOS os runs do branch=${branch}`);
            for await (const page of github.paginate.iterator(
              github.rest.actions.listWorkflowRunsForRepo,
              { owner, repo, branch, per_page: 100 }
            )) {
              for (const run of page.data) {
                runsTotal++;
                try {
                  await safeCall(
                    () => github.rest.actions.deleteWorkflowRun({ owner, repo, run_id: run.id }),
                    `deleteRun id=${run.id}`
                  );
                  runsDeleted++;
                } catch (e) {
                  runsFailed++;
                  core.warning(`Run ${run.id} falhou: ${e.message}`);
                }
              }
            }
            core.endGroup();
            core.summary.addHeading('Runs')
              .addTable([['Total','Deleted','Failed'],[String(runsTotal), String(runsDeleted), String(runsFailed)]]);

            // ---------- 3) RELEASES ----------
            let relDeleted = 0, relFailed = 0;
            core.startGroup('üßπ Apagar releases (target=branch ou autor=bot ou tag=prefix)');
            for await (const page of github.paginate.iterator(
              github.rest.repos.listReleases,
              { owner, repo, per_page: 100 }
            )) {
              for (const r of page.data) {
                const byBot = r.author?.login === 'github-actions[bot]';
                const fromBranch = r.target_commitish === branch;
                const tagMatches = (r.tag_name || '').startsWith(tagPrefix);
                if (byBot || fromBranch || tagMatches) {
                  try {
                    await safeCall(
                      () => github.rest.repos.deleteRelease({ owner, repo, release_id: r.id }),
                      `deleteRelease id=${r.id} tag=${r.tag_name}`
                    );
                    relDeleted++;
                  } catch (e) {
                    relFailed++;
                    core.warning(`Release ${r.id} (${r.tag_name}) falhou: ${e.message}`);
                  }
                }
              }
            }
            core.endGroup();
            core.summary.addHeading('Releases')
              .addTable([['Deleted','Failed'],[String(relDeleted), String(relFailed)]]);

            // ---------- 4) TAGS ----------
            let tagsDeleted = 0, tagsFailed = 0;
            core.startGroup(`üßπ Apagar tags com prefixo ${tagPrefix}`);
            async function listMatchingRefs(refPrefix, page=1) {
              return (await safeCall(
                () => github.request('GET /repos/{owner}/{repo}/git/matching-refs/{ref}', {
                  owner, repo, ref: `tags/${refPrefix}`, per_page: 100, page
                }),
                `listMatchingRefs page=${page}`
              )).data ?? [];
            }
            for (let page=1;; page++) {
              const refs = await listMatchingRefs(tagPrefix, page);
              if (!refs.length) break;
              for (const ref of refs) {
                const full = ref.ref; // "refs/tags/<tag>"
                const shortRef = full.replace(/^refs\//,''); // "tags/<tag>"
                try {
                  await safeCall(
                    () => github.request('DELETE /repos/{owner}/{repo}/git/refs/{ref}', {
                      owner, repo, ref: shortRef
                    }),
                    `deleteTag ${shortRef}`
                  );
                  tagsDeleted++;
                } catch (e) {
                  tagsFailed++;
                  core.warning(`Tag ${shortRef} falhou: ${e.message}`);
                }
              }
            }
            core.endGroup();
            core.summary.addHeading('Tags')
              .addTable([['Prefix','Deleted','Failed'],[tagPrefix, String(tagsDeleted), String(tagsFailed)]]);

            core.summary.addSeparator()
              .addRaw(`NEAR_LIMIT threshold: ${NEAR_LIMIT}\n`)
              .addLink('Ver rate limit atual', 'https://api.github.com/rate_limit')
              .write();
