name: Nuke Actions (runs, artifacts, releases, tags) [autosleep]

on:
  workflow_dispatch:
    inputs:
      branch:
        description: Branch a limpar
        default: main
        required: true
      tagPrefix:
        description: Prefixo de tags a remover (refs/tags/<prefix>*)
        default: release-
        required: true
      nearLimitThreshold:
        description: Faz sleep quando faltarem <= este n¬∫ de requests
        default: "50"
        required: true

permissions:
  actions: write     # apagar runs + artifacts
  contents: write    # apagar releases + tags

jobs:
  nuke:
    runs-on: ubuntu-latest
    timeout-minutes: 360
    steps:
      - name: Nuke repo artifacts/runs/releases/tags (com auto-wait)
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const branch = core.getInput('branch') || 'main';
            const tagPrefix = core.getInput('tagPrefix') || 'release-';
            const NEAR_LIMIT = parseInt(core.getInput('nearLimitThreshold') || '50', 10);

            const sleep = (ms) => new Promise(r => setTimeout(r, ms));

            async function getRate() {
              const r = await github.request('GET /rate_limit');
              return r.data.resources.core; // {limit, remaining, reset}
            }

            async function waitForReset(resetEpochSec) {
              const now = Math.floor(Date.now()/1000);
              const waitSec = Math.max(0, resetEpochSec - now) + 5; // +5s margem
              core.info(`‚è≥ A aguardar ${waitSec}s at√© ao reset de rate limit...`);
              await sleep(waitSec*1000);
            }

            async function ensureBudget() {
              const coreRate = await getRate();
              core.info(`üîã Budget: remaining=${coreRate.remaining}/${coreRate.limit} (reset @ ${new Date(coreRate.reset*1000).toISOString()})`);
              if (coreRate.remaining <= NEAR_LIMIT) {
                await waitForReset(coreRate.reset);
              }
            }

            async function safeCall(fn, label) {
              for (let attempt=1; attempt<=5; attempt++) {
                try {
                  await ensureBudget();
                  return await fn();
                } catch (e) {
                  const status = e.status || e?.response?.status;
                  const msg = e.message || (e?.response?.data?.message);
                  const reset = Number(e?.response?.headers?.['x-ratelimit-reset'] || 0);
                  core.warning(`${label} ‚Üí erro (attempt ${attempt}): ${status} ${msg || ''}`);

                  // Se √© rate limit, espera at√© ao reset e retenta
                  if (status === 403 && /rate limit/i.test(String(msg))) {
                    if (reset) {
                      await waitForReset(reset);
                      continue;
                    } else {
                      await sleep(60_000);
                      continue;
                    }
                  }

                  // Se n√£o for rate limit, umas tentativas r√°pidas com backoff
                  await sleep(attempt * 3000);
                }
              }
              // Lan√ßar de volta o √∫ltimo erro (ir√° aparecer como warning no summary)
              throw new Error(`${label} falhou ap√≥s retries.`);
            }

            // ---------- 1) ARTIFACTS ----------
            let artifactsDeleted = 0, artifactsFailed = 0;
            core.startGroup('üßπ Apagar TODOS os artifacts (repo-wide)');
            for await (const page of github.paginate.iterator(
              github.rest.actions.listArtifactsForRepo,
              { owner, repo, per_page: 100 }
            )) {
              for (const art of page.data) {
                try {
                  await safeCall(
                    () => github.rest.actions.deleteArtifact({ owner, repo, artifact_id: art.id }),
                    `deleteArtifact id=${art.id} name=${art.name}`
                  );
                  artifactsDeleted++;
                } catch (e) {
                  artifactsFailed++;
                  core.warning(`Artifact ${art.id} (${art.name}) falhou: ${e.message}`);
                }
              }
            }
            core.endGroup();
            core.summary.addHeading('Artifacts')
              .addTable([['Deleted','Failed'],[String(artifactsDeleted), String(artifactsFailed)]]);

            // ---------- 2) RUNS ----------
            let runsTotal = 0, runsDeleted = 0, runsFailed = 0;
            core.startGroup(`üßπ Apagar TODOS os runs do branch=${branch}`);
            for await (const page of github.paginate.iterator(
              github.rest.actions.listWorkflowRunsForRepo,
              { owner, repo, branch, per_page: 100 }
            )) {
              for (const run of page.data) {
                runsTotal++;
                try {
                  await safeCall(
                    () => github.rest.actions.deleteWorkflowRun({ owner, repo, run_id: run.id }),
                    `deleteRun id=${run.id}`
                  );
                  runsDeleted++;
                } catch (e) {
                  runsFailed++;
                  core.warning(`Run ${run.id} falhou: ${e.message}`);
                }
              }
            }
            core.endGroup();
            core.summary.addHeading('Runs')
              .addTable([['Total','Deleted','Failed'],[String(runsTotal), String(runsDeleted), String(runsFailed)]]);

            // ---------- 3) RELEASES ----------
            let relDeleted = 0, relFailed = 0;
            core.startGroup('üßπ Apagar releases (target=branch ou autor=bot ou tag=prefix)');
            for await (const page of github.paginate.iterator(
              github.rest.repos.listReleases,
              { owner, repo, per_page: 100 }
            )) {
              for (const r of page.data) {
                const byBot = r.author?.login === 'github-actions[bot]';
                const fromBranch = r.target_commitish === branch;
                const tagMatches = (r.tag_name || '').startsWith(tagPrefix);
                if (byBot || fromBranch || tagMatches) {
                  try {
                    await safeCall(
                      () => github.rest.repos.deleteRelease({ owner, repo, release_id: r.id }),
                      `deleteRelease id=${r.id} tag=${r.tag_name}`
                    );
                    relDeleted++;
                  } catch (e) {
                    relFailed++;
                    core.warning(`Release ${r.id} (${r.tag_name}) falhou: ${e.message}`);
                  }
                }
              }
            }
            core.endGroup();
            core.summary.addHeading('Releases')
              .addTable([['Deleted','Failed'],[String(relDeleted), String(relFailed)]]);

            // ---------- 4) TAGS ----------
            let tagsDeleted = 0, tagsFailed = 0;
            core.startGroup(`üßπ Apagar tags com prefixo ${tagPrefix}`);
            async function listMatchingRefs(refPrefix, page=1) {
              const res = await safeCall(
                () => github.request('GET /repos/{owner}/{repo}/git/matching-refs/{ref}', {
                  owner, repo, ref: `tags/${refPrefix}`, per_page: 100, page
                }),
                `listMatchingRefs page=${page}`
              );
              return res.data ?? [];
            }
            // Pagina√ß√£o manual para matching-refs
            for (let page=1;; page++) {
              const refs = await listMatchingRefs(tagPrefix, page);
              if (!refs.length) break;
              for (const ref of refs) {
                const full = ref.ref;         // "refs/tags/<tag>"
                const shortRef = full.replace(/^refs\//,''); // "tags/<tag>"
                try {
                  await safeCall(
                    () => github.request('DELETE /repos/{owner}/{repo}/git/refs/{ref}', {
                      owner, repo, ref: shortRef
                    }),
                    `deleteTag ${shortRef}`
                  );
                  tagsDeleted++;
                } catch (e) {
                  tagsFailed++;
                  core.warning(`Tag ${shortRef} falhou: ${e.message}`);
                }
              }
            }
            core.endGroup();
            core.summary.addHeading('Tags')
              .addTable([['Prefix','Deleted','Failed'],[tagPrefix, String(tagsDeleted), String(tagsFailed)]]);

            // Summary final
            core.summary.addSeparator()
              .addRaw(`NEAR_LIMIT threshold: ${NEAR_LIMIT}\n`)
              .addLink('Ver rate limit atual', 'https://api.github.com/rate_limit')
              .write();
